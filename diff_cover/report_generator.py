"""
Classes for generating diff coverage reports.
"""

from abc import ABCMeta, abstractmethod
from lazy import lazy
from textwrap import dedent


class DiffViolations(object):
    """
    Class to capture violations generated by a particular diff
    """
    def __init__(self, violations, measured_lines, diff_lines):
        self.violations = violations
        self.lines = set(violation.line for violation in violations).intersection(diff_lines)

        if measured_lines is None:
            self.measured_lines = set(diff_lines)
        else:
            self.measured_lines = set(measured_lines).intersection(diff_lines)


class BaseReportGenerator(object):
    """
    Generate a diff coverage report.
    """

    __metaclass__ = ABCMeta

    def __init__(self, violations_reporter, diff_reporter):
        """
        Configure the report generator to build a report
        from `violations_reporter` (of type BaseViolationReporter)
        and `diff_reporter` (of type BaseDiffReporter)
        """
        self._violations = violations_reporter
        self._diff = diff_reporter

        self._cache_violations = None

    @abstractmethod
    def generate_report(self, output_file):
        """
        Write the report to `output_file`, which is a file-like
        object implementing the `write()` method.

        Concrete subclasses should access diff coverage info
        using the base class methods.
        """
        pass

    def coverage_report_name(self):
        """
        Return the name of the coverage report.
        """
        return self._violations.name()

    def diff_report_name(self):
        """
        Return the name of the diff.
        """
        return self._diff.name()

    def src_paths(self):
        """
        Return a list of source files in the diff
        for which we have coverage information.
        """
        return set(src for src, summary in self._diff_violations.items() if len(summary.measured_lines) > 0)

    def percent_covered(self, src_path):
        """
        Return an integer percent of lines covered for the source
        in `src_path`.

        If we have no coverage information for `src_path`, returns None
        """
        diff_violations = self._diff_violations.get(src_path)

        if diff_violations is None:
            return None

        uncovered = diff_violations.lines
        percent_covered = 100 - float(len(uncovered)) / len(diff_violations.measured_lines) * 100

        return percent_covered

    def missing_lines(self, src_path):
        """
        Return a list of missing lines (integers) in `src_path` that were changed.

        If we have no coverage information for `src_path`, returns
        an empty list.
        """

        diff_violations = self._diff_violations.get(src_path)

        if diff_violations is None:
            return []

        return sorted(diff_violations.lines)

    def total_num_lines(self):
        """
        Return the total number of lines in the diff for
        which we have coverage info.
        """

        return sum([len(summary.measured_lines) for summary
                    in self._diff_violations.values()])

    def total_num_missing(self):
        """
        Returns the total number of lines in the diff
        that should be covered, but aren't.
        """

        return sum(
            len(summary.lines)
            for summary
            in self._diff_violations.values()
        )

    def total_percent_covered(self):
        """
        Returns the percent of lines in the diff that are covered.
        (only counting lines for which we have coverage info).
        """
        total_lines = self.total_num_lines()
        num_covered = total_lines - self.total_num_missing()
        return int(float(num_covered) / total_lines * 100)

    @lazy
    def _diff_violations(self):
        """
        Returns a dictionary of the form:

            { SRC_PATH: DiffViolations(SRC_PATH) }

        where `SRC_PATH` is the path to the source file.

        To make this efficient, we cache and reuse the result.
        """
        return {
            src_path: DiffViolations(
                self._violations.violations(src_path),
                self._violations.measured_lines(src_path),
                self._diff.lines_changed(src_path),
            ) for src_path in self._diff.src_paths_changed()
        }


class StringReportGenerator(BaseReportGenerator):
    """
    Generate a string diff coverage report.
    """

    def generate_report(self, output_file):
        """
        Write a basic string report to `output_file`.
        """

        # Header line
        self._print_divider(output_file)
        output_file.write("Diff Coverage\n")
        output_file.write("Coverage Report: {0}\n".format(
                          self.coverage_report_name()))
        output_file.write("Diff: {0}\n".format(
                          self.diff_report_name()))
        self._print_divider(output_file)

        # If no coverage information, explain this
        if len(self.src_paths()) == 0:
            msg = "No lines with coverage information in this diff.\n"
            output_file.write(msg)

        else:

            # Source file stats
            for src_path in self.src_paths():
                self._print_src_path_stats(src_path, output_file)

            # Summary stats
            self._print_divider(output_file)
            self._print_summary_stats(output_file)

        self._print_divider(output_file)

    @staticmethod
    def _print_divider(output_file):
        """
        Print a divider line to `output_file`.
        """
        output_file.write("-------------\n")

    def _print_src_path_stats(self, src_path, output_file):
        """
        Print statistics about the source file at `src_path`.
        `output_file` is the file to write to.
        """
        # Calculate percent coverage
        percent_covered = self.percent_covered(src_path)

        # Find missing lines
        missing_lines = [str(line) for line
                         in self.missing_lines(src_path)]

        # Print the info
        if percent_covered < 100.0:
            info_str = "{0} ({1:.1f}%): Missing line(s) {2}\n".format(\
                        src_path, percent_covered,
                        ",".join(missing_lines))
        else:
            info_str = "{0} (100%)\n".format(src_path)

        output_file.write(info_str)

    def _print_summary_stats(self, output_file):
        """
        Print statistics summarizing the coverage of the entire diff.
        `output_file` is the file to write to.
        """

        info_str = dedent("""
        Total:   {0} line(s)
        Missing: {1} line(s)
        Coverage: {2:.0f}%
        """.format(self.total_num_lines(),
                   self.total_num_missing(),
                   self.total_percent_covered())).strip()

        output_file.write(info_str + "\n")


class HtmlReportGenerator(BaseReportGenerator):
    """
    Generate an HTML formatted diff coverage report.
    """

    DOCTYPE = ('<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" ' +
              '"http://www.w3.org/TR/html4/strict.dtd">')

    META = ("<meta http-equiv='Content-Type' " +
            "content='text/html; charset=utf-8'>")

    TITLE = "<title>Diff Coverage</title>"
    CONTENT_TITLE = "<h1>Diff Coverage</h1>"
    TABLE_HEADER = ('<table border="1">\n' +
                    '<tr>\n<th>Source File</th>\n' +
                    '<th>Diff Coverage (%)</th>\n' +
                    '<th>Missing Line(s)</th>\n</tr>')

    def generate_report(self, output_file):
        """
        Write an HTML-formatted report to `output_file`.
        """

        # Header
        output_file.write(self.DOCTYPE + '\n')
        output_file.write('<html>\n<head>\n')
        output_file.write(self.META + '\n')
        output_file.write(self.TITLE + '\n')
        output_file.write('</head>\n')

        # Body
        output_file.write('<body>\n')
        output_file.write(self.CONTENT_TITLE + '\n')

        # Source report names
        output_file.write("<p>Coverage Report: {0}</p>\n".format(
                         self.coverage_report_name()))
        output_file.write("<p>Diff: {0}</p>\n".format(
                         self.diff_report_name()))

        # If no coverage information, explain this
        if len(self.src_paths()) == 0:
            msg = "<p>No lines with coverage information in this diff.</p>\n"
            output_file.write(msg)

        else:

            # Start the table
            output_file.write(self.TABLE_HEADER + '\n')

            # Source file information
            for src_path in self.src_paths():
                self._print_src_path_stats(src_path, output_file)

            # Close the table
            output_file.write('</table>\n')

            # Summary stats
            self._print_summary_stats(output_file)

        # Closing tags
        output_file.write('</body>\n</html>')

    def _print_src_path_stats(self, src_path, output_file):
        """
        Print statistics about the source file at `src_path`.
        `output_file` is the file to write to.
        """
        # Calculate percent coverage
        percent_covered = self.percent_covered(src_path)

        # Find missing lines
        missing_lines = [str(line) for line
                         in self.missing_lines(src_path)]

        # Print the info
        if percent_covered < 100.0:
            info_str = dedent("""
            <tr>
            <td>{0}</td>
            <td>{1:.1f}%</td>
            <td>{2}</td>
            </tr>""".format(src_path, percent_covered,
                            ",".join(missing_lines))).strip()
        else:
            info_str = dedent("""
            <tr>
            <td>{0}</td>
            <td>100%</td>
            <td>&nbsp;</td>
            </tr>""".format(src_path)).strip()

        output_file.write(info_str + '\n')

    def _print_summary_stats(self, output_file):
        """
        Print statistics summarizing the coverage of the entire diff.
        `output_file` is the file to write to.
        """
        info_str = dedent("""
        <ul>
        <li><b>Total</b>: {0} line(s)</li>
        <li><b>Missing</b>: {1} line(s)</li>
        <li><b>Coverage</b>: {2:.0f}%</li>
        </ul>
        """.format(self.total_num_lines(),
                   self.total_num_missing(),
                   self.total_percent_covered())).strip()

        output_file.write(info_str + '\n')
